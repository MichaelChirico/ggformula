% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate_model.R
\name{evaluate_model}
\alias{evaluate_model}
\title{Evaluate a model for specified inputs}
\usage{
evaluate_model(model = NULL, data = NULL, on_training = FALSE,
  nlevels = 3, at = list(), ...)
}
\arguments{
\item{model}{the model to display graphically}

\item{data}{optional data set from which to extract levels for explanatory variables}

\item{on_training}{flag whether to use the training data for evaluation. Only needed
when there are random terms, e.g. from \code{rand()}, \code{shuffle()}, .... See details.}

\item{nlevels}{how many levels to construct for input variables.
For quantitative variables, this is a suggestion. \code{pretty()} will determine}

\item{at}{named list giving specific values at which to hold the variables. Use this to 
override the automatic generation of levels for any or all explanatory variables.}

\item{...}{arguments to predict()}
}
\value{
A dataframe containing both the explanatory variable inputs and
the resulting model output (in the `model_value` field). This differs from the output
of \code{predict()}, which for many model classes/architectures may be a vector or matrix.
}
\description{
Find the model outputs for specified inputs. This is equivalent to the 
generic \code{predict()} function, except it will choose sensible values
by default.  This simplifies getting a quick look at model values.
}
\details{
There are two ways to evaluate the model on the training data. The first is
to set the \code{data} argument to the same data frame used to train the model. The second
is to use the \code{on_training = TRUE} argument. These are equivalent unless there is
some random component among the explanatory terms, as with `mosaic::rand()`, `mosaic::shuffle()` and so on.
}
\examples{
\dontrun{mod1 <- lm(wage ~ age * sex + sector, data = mosaicData::CPS85)
evaluate_model(mod1)
mod3 <- glm(married == "Married" ~ age + sex * sector,
            data = mosaicData::CPS85, family = "binomial")
evaluate_model(mod3, nlevels = 2, type = "response")
evaluate_model(mod3, nlevels = 2, type = "response", at = list(sex = "F"))
}
}

